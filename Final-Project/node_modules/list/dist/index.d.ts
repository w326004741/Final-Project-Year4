export declare function setEquals(equals: (a: any, b: any) => boolean): void;
export declare type Sizes = number[] | undefined;
export declare class Node {
    sizes: Sizes;
    array: any[];
    constructor(sizes: Sizes, array: any[]);
}
export declare function nth<A>(index: number, l: List<A>): A | undefined;
export declare class List<A> {
    bits: number;
    offset: number;
    length: number;
    root: Node | undefined;
    suffix: A[];
    prefix: A[];
    constructor(bits: number, offset: number, length: number, root: Node | undefined, suffix: A[], prefix: A[]);
    [Symbol.iterator](): Iterator<A>;
}
export declare function prepend<A>(value: A, l: List<A>): List<A>;
export declare function append<A>(value: A, l: List<A>): List<A>;
export declare function list<A>(...elements: A[]): List<A>;
export declare function of<A>(a: A): List<A>;
export declare function pair<A>(first: A, second: A): List<A>;
export declare function empty(): List<any>;
export declare function repeat<A>(value: A, times: number): List<A>;
/**
 * Generates a new list by calling a function with the current index
 * `n` times.
 * @param func Function used to generate list values.
 * @param times Number of values to generate.
 */
export declare function times<A>(func: (index: number) => A, times: number): List<A>;
/**
 * Gets the length of a list.
 *
 * @example
 * length(list(0, 1, 2, 3)); //=> 4
 *
 * @param l The list to get the length of.
 */
export declare function length(l: List<any>): number;
export declare function first<A>(l: List<A>): A | undefined;
export declare function last<A>(l: List<A>): A | undefined;
export declare function map<A, B>(f: (a: A) => B, l: List<A>): List<B>;
export declare function pluck<A, K extends keyof A>(key: K, l: List<A>): List<A[K]>;
export declare function range(start: number, end: number): List<number>;
/**
 * Folds a function over a list. Left-associative.
 *
 * @example
 * foldl((n, m) => n - m, 1, list(2, 3, 4, 5)); //=> -13
 */
export declare function foldl<A, B>(f: (acc: B, value: A) => B, initial: B, l: List<A>): B;
export declare const reduce: typeof foldl;
export declare function forEach<A>(callback: (a: A) => void, l: List<A>): void;
export declare function filter<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function reject<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function partition<A>(predicate: (a: A) => boolean, l: List<A>): List<List<A>>;
export declare function join(separator: string, l: List<string>): string;
export declare function foldr<A, B>(f: (value: A, acc: B) => B, initial: B, l: List<A>): B;
export declare const reduceRight: typeof foldr;
export declare function ap<A, B>(listF: List<(a: A) => B>, l: List<A>): List<B>;
export declare function flatten<A>(nested: List<List<A>>): List<A>;
export declare function chain<A, B>(f: (a: A) => List<B>, l: List<A>): List<B>;
export declare function every<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare const all: typeof every;
export declare function some<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare const any: typeof some;
export declare function none<A>(predicate: (a: A) => boolean, l: List<A>): boolean;
export declare function find<A>(predicate: (a: A) => boolean, l: List<A>): A | undefined;
export declare function indexOf<A>(element: A, l: List<A>): number;
export declare function findIndex<A>(predicate: (a: A) => boolean, l: List<A>): number;
export declare function includes<A>(element: A, l: List<A>): boolean;
export declare const contains: typeof includes;
export declare function equals<A>(firstList: List<A>, secondList: List<A>): boolean;
export declare function concat<A>(left: List<A>, right: List<A>): List<A>;
export declare function update<A>(index: number, a: A, l: List<A>): List<A>;
export declare function adjust<A>(f: (a: A) => A, index: number, l: List<A>): List<A>;
export declare function slice<A>(from: number, to: number, l: List<A>): List<A>;
export declare function take<A>(n: number, l: List<A>): List<A>;
export declare function takeWhile<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function dropWhile<A>(predicate: (a: A) => boolean, l: List<A>): List<A>;
export declare function takeLast<A>(n: number, l: List<A>): List<A>;
export declare function splitAt<A>(index: number, l: List<A>): [List<A>, List<A>];
export declare function remove<A>(from: number, amount: number, l: List<A>): List<A>;
export declare function drop<A>(n: number, l: List<A>): List<A>;
export declare function dropLast<A>(n: number, l: List<A>): List<A>;
export declare function pop<A>(l: List<A>): List<A>;
export declare const init: typeof pop;
export declare function tail<A>(l: List<A>): List<A>;
export declare function toArray<A>(l: List<A>): A[];
export declare function fromArray<A>(array: A[]): List<A>;
export declare function fromIterable<A>(iterable: IterableIterator<A>): List<A>;
export declare function insert<A>(index: number, element: A, l: List<A>): List<A>;
export declare function insertAll<A>(index: number, elements: List<A>, l: List<A>): List<A>;
/**
 * Reverses a list.
 * @category Updater
 * @param l The list to reverse.
 * @returns A reversed list.
 */
export declare function reverse<A>(l: List<A>): List<A>;
export declare function isList<A>(l: any): l is List<A>;
export declare function zipWith<A, B, C>(f: (a: A, b: B) => C, as: List<A>, bs: List<B>): List<C>;
export declare function zip<A, B>(as: List<A>, bs: List<B>): List<[A, B]>;
